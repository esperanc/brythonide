import sys
import traceback

from browser import (document, window, alert, console, prompt, html,
    highlight, bind, run_script)
from browser.template import Template

# name of currently edited script
current = None

docs = {}

# current number of lines
current_nb_lines = 1

# boolean for code highlighting
is_highlighted = False

IDB = window.indexedDB

def close(evt, elt):
    global current
    open_scripts.remove(current)
    del docs[current]
    editor.text = ""
    print_line_nums()
    draw_file_browser()

def create_db(*args):
    # The database did not previously exist, so create object store.
    db = request.result
    store = db.createObjectStore("scripts", {"keyPath": "name"})

request = IDB.open("brython_scripts")

# If database doesn't exist, create it
request.bind('upgradeneeded', create_db)

def new(evt, elt):
    global current
    current = "script1.py"
    docs["current"] = ""
    open_scripts.append(current)
    editor.text = ""
    draw_file_browser()
    print_line_nums()

def load(evt, elt):
    """Get all the scripts in the database and open a dialog window to select
    one for opening.
    """
    global scripts
    db = request.result
    tx = db.transaction("scripts", "readonly")
    store = tx.objectStore("scripts")
    cursor = store.openCursor()

    dialog_window.style.display = "block"
    dialog.clear()

    dialog_title = dialog_window.select_one(".dialog_title")
    dialog_title.clear()
    dialog_title <= html.SPAN("Open file...")

    scripts = []
    def get_scripts(evt):
        res = evt.target.result
        if res:
            scripts.append(res.value.name)
            getattr(res, "continue")()
        else:
            scripts.sort()
            for script in scripts:
                dialog <= html.SPAN(script) + html.BR()
            for elt in dialog.childNodes:
                elt.bind("click", open_script)

    cursor.bind('success', get_scripts)


def open_script(evt):
    """Open one of the scripts shown in the dialog window generated by
    load().
    """
    global current, current_nb_lines
    if current is not None:
        docs[current] = editor.text
    current = evt.target.text
    db = request.result
    tx = db.transaction("scripts", "readonly")
    store = tx.objectStore("scripts")
    req = store.get(current)

    def success(evt):
        if not hasattr(req, "result"):
            print("not found")
        else:
            editor.text = req.result.content
            docs[current] = req.result.content
            current_nb_lines = editor.text.count("\n")
            if not current in open_scripts:
                open_scripts.append(current)
            draw_file_browser()
            print_line_nums()

    dialog_window.style.display = "none"

    req.bind("success", success)

def show_script(evt):
    """Called when user clicks on a script name in the file browser."""
    global current
    if current is not None:
        docs[current] = editor.text
    current = evt.target.text
    editor.text = docs[current]
    draw_file_browser()
    print_line_nums()

def draw_file_browser():
    filebrowser.clear()
    open_scripts.sort()
    filebrowser <= (html.SPAN(s) + html.BR() for s in open_scripts)
    for span in filebrowser.select("span"):
        span.bind("click", show_script)
        if span.text.strip() == current:
            span.style.backgroundColor = "#888"

def print_line_nums():
    nb_lines = editor.text.count("\n") or 1
    linenum.clear()
    linenum.text = "\n".join(str(i) for i in range(1, nb_lines + 1))
    document["linenum_wrapper"].scrollTo(0, editor.scrollTop)

def save_as(evt, elt):
    """Save current script with a new name."""
    name = prompt("Name")
    if name:
        _save(name)

def _save(name):
    """Save the script in the database."""
    global current
    db = request.result
    tx = db.transaction("scripts", "readwrite")
    store = tx.objectStore("scripts")
    cursor = store.openCursor()
    data = {"name": name, "content": editor.text}
    store.put(data)

    # when record is added, show message
    def ok(evt):
        alert("saved")
        current = name
        if not name in open_scripts:
            open_scripts.append(name)
        draw_file_browser()

    cursor.bind('success', ok)

def save(evt, elt):
    _save(current)

def delete(evt, elt):
    """Delete a script from the database."""
    dialog_window.style.display = "block"
    dialog.clear()

    dialog_title = dialog_window.select_one(".dialog_title")
    dialog_title.clear()
    dialog_title <= html.SPAN("Remove script")

    dialog <= f"Do you really want to delete script {current} ?"
    dialog <= html.P()
    dialog <= html.BUTTON("Ok") + html.BUTTON("Cancel")

    @bind(dialog.select("button")[0], "click")
    def confirm_delete(evt):
        db = request.result
        tx = db.transaction("scripts", "readwrite")
        store = tx.objectStore("scripts")
        cursor = store.delete(current)
        dialog_window.style.display = "none"

        # when record is added, show message
        def ok(evt):
            open_scripts.remove(current)
            editor.text = ""
            print_line_nums()
            draw_file_browser()

        cursor.bind("success", ok)

    @bind(dialog.select("button")[1], "click")
    def cancel_delete(evt):
        dialog_window.style.display = "none"

def _fsize():
    body_style = window.getComputedStyle(document.body, None)
    fontSize = body_style.getPropertyValue("font-size")
    fsize = float(fontSize.rstrip("px"))
    return fsize

def size_up(evt, elt):
    """Increment font size."""
    fsize = _fsize() + 1
    document.body.style.fontSize = f"{fsize}px"

def size_down(evt, elt):
    """Decrement font size."""
    fsize = _fsize() - 1
    document.body.style.fontSize = f"{fsize}px"

def syntax_highlight(evt, elt):
    global is_highlighted
    if not is_highlighted:
        colored = highlight.highlight(editor.text)
        editor.html = colored.html
    else:
        editor.html = editor.text
    is_highlighted = not is_highlighted

def run(evt, elt):
    """Execute current script."""
    save_stdout = sys.stdout
    save_stderr = sys.stderr
    stdout = Output()
    sys.stdout = sys.stderr = stdout
    output_window.style.display = "block"
    output.text = ""
    try:
        run_script(editor.text, current)
    finally:
        sys.stdout = save_stdout
        sys.stderr = save_stderr

width = window.innerWidth
height = window.innerHeight

tmpl = Template("content",
    [new, run, load, save, save_as, close, delete, size_up, size_down,
        syntax_highlight])

tmpl.render(editor_height=int(0.9 * height),
    height=int(0.6 * height), width=int(0.6 * width),
    top=int(0.2 * height), left=int(0.2 * width))

Template("dialog_window").render(
    height=int(0.6 * height), width=int(0.6 * width),
    top=int(0.2 * height), left=int(0.2 * width))

dialog = document["dialog"]

filebrowser = document["filebrowser"]
scripts = []
open_scripts = []

def close_window(evt):
    button = evt.target
    w = button.closest("div")
    w.style.display = "none"

for btn in document.select(".dialog_close"):
    btn.bind("click", close_window)

delta = [0, 0]
moving = None

def drag_start(evt):
    global moving, delta
    moving = evt.target.closest("div")
    delta = [evt.x, evt.y]
    evt.preventDefault()
    evt.stopPropagation()

def drag(evt):
    if moving is not None:
        dx, dy = evt.x - delta[0], evt.y - delta[1]
        pos = offset[moving.id]
        pos[0] += dx
        pos[1] += dy
        delta[0] = evt.x
        delta[1] = evt.y
        moving.style.transform = "translate({}px,{}px)".format(*pos)
    evt.preventDefault()
    evt.stopPropagation()

def drop(evt):
    global moving
    moving = None
    evt.preventDefault()
    evt.stopPropagation()

offset = {}
for bar in document.select(".dialog_bar"):
    div = bar.closest("div")
    offset[div.id] = [0, 0]
    bar.bind("mousedown", drag_start)
    bar.bind("mousemove", drag)
    bar.bind("mouseup", drop)
    bar.bind("mouseout", drop)


output_window = document["output_window"]

dialog_window = document["dialog_window"]

output = document["output"]
editor = document["editor"]
linenum = document["linenum"]

# hacks to hide the linenum scrollbar
textareaWidth = document["linenum_wrapper"].scrollWidth
linenum.style.width = f"{textareaWidth}px"

editor.text = ""
print_line_nums()
editor.focus()

indent = 0

def get_indent():
    """When user hits the Enter key, set global variables indent and
    start_block."""
    global indent
    sel = document.getSelection()
    _range = sel.getRangeAt(0)
    line_start = _range.startOffset
    text = sel.anchorNode.text
    indent = len(text) - len(text.lstrip())
    if text.rstrip().endswith(":"):
        indent += 4

def insert_spaces(nb):
    # insert four non-breaking spaces for the tab key
    sel = document.getSelection()
    _range = sel.getRangeAt(0)

    tabNode = document.createTextNode(" " * nb)
    _range.insertNode(tabNode)

    _range.setStartAfter(tabNode)
    _range.setEndAfter(tabNode)
    sel.removeAllRanges()
    sel.addRange(_range)

@bind(editor, "keyup")
def keyup(evt):
    if evt.keyCode in [8, 13, 17, 46]:
        # cr, delete, ctrl, backspace
        print_line_nums()
    elif evt.keyCode == 9:
        evt.preventDefault()

    if evt.keyCode == 13:
        insert_spaces(indent)

@bind(editor, "keypress")
def keypress(evt):
    if evt.keyCode == 9: # tab key
        sel = document.getSelection()
        evt.preventDefault()
        insert_spaces(4)
    if evt.keyCode == 13: # CR
        # store indent
        get_indent()

@bind(editor, "scroll")
def scroll(evt):
    document["linenum_wrapper"].scrollTo(0, evt.target.scrollTop)

class Output:

    def write(self, *args):
        for arg in args:
            output.text += str(arg)

